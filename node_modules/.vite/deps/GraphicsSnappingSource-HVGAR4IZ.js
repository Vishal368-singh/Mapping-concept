import {
  i as i2,
  o
} from "./chunk-6DCXQOET.js";
import "./chunk-VE6EHKKT.js";
import "./chunk-32GGXKR7.js";
import "./chunk-YH7GPSW7.js";
import "./chunk-3KDNHMA3.js";
import {
  t
} from "./chunk-YKE7YQGP.js";
import "./chunk-CRVQAW6F.js";
import {
  E,
  y as y3
} from "./chunk-WMXZPLHN.js";
import "./chunk-37USNU2Q.js";
import "./chunk-C4QP4LFT.js";
import {
  A
} from "./chunk-PWMG7PVD.js";
import "./chunk-I3EB2Q35.js";
import {
  y as y2
} from "./chunk-WHNSSW5C.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-HUR2TTV7.js";
import {
  a as a3
} from "./chunk-R4U6PM2D.js";
import "./chunk-DPEZN2CZ.js";
import "./chunk-6T6LJGGM.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import {
  i,
  n,
  r as r2
} from "./chunk-ZJ2O726Y.js";
import {
  u
} from "./chunk-6GWZRS3D.js";
import {
  f
} from "./chunk-P55IKTJZ.js";
import "./chunk-PVUHK5FP.js";
import "./chunk-ITDL4YVK.js";
import {
  L as L2
} from "./chunk-LHDS43CC.js";
import "./chunk-CCQBS25D.js";
import "./chunk-TBTLKLMN.js";
import "./chunk-SOILZBUC.js";
import "./chunk-WXBUIB3W.js";
import "./chunk-OXO3GGCE.js";
import {
  ut
} from "./chunk-MP5M3F6E.js";
import "./chunk-7Y4U2JD3.js";
import {
  s as s2
} from "./chunk-GCTSCKPO.js";
import "./chunk-6U4EGJOK.js";
import "./chunk-W7U4L72B.js";
import "./chunk-DDDZPNGZ.js";
import "./chunk-UZFYMLRD.js";
import "./chunk-BCUZY6HJ.js";
import "./chunk-EVMYKI66.js";
import "./chunk-4SIT2BLP.js";
import "./chunk-RWNJO2QP.js";
import "./chunk-6EYNEIU4.js";
import "./chunk-2EW4QRCK.js";
import "./chunk-7HWQNQIF.js";
import "./chunk-REIVHO5B.js";
import "./chunk-7IV6VAPN.js";
import "./chunk-WX3VZIBK.js";
import "./chunk-2RL34CVC.js";
import {
  h as h3
} from "./chunk-AGQYHEEP.js";
import {
  g as g2
} from "./chunk-JTZ24OTF.js";
import "./chunk-YNVT2YMA.js";
import "./chunk-MFUILZVS.js";
import "./chunk-FCLAVZUU.js";
import "./chunk-KPGNM4LZ.js";
import "./chunk-BNQMKYX6.js";
import "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import "./chunk-C7LICITY.js";
import "./chunk-7WPGDYQW.js";
import "./chunk-OTNN4DZS.js";
import "./chunk-CVYSDEQD.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-OUR2XGMQ.js";
import "./chunk-RYA5LLOM.js";
import {
  Z
} from "./chunk-XZ46MCDO.js";
import "./chunk-UICDKBDP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-G2VWR52Q.js";
import "./chunk-EMULKSUV.js";
import "./chunk-AY3JR4QM.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-U5KBQRKK.js";
import "./chunk-L2J7BAWS.js";
import "./chunk-7CUUAFJU.js";
import "./chunk-RSDQMJRT.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-ORDYVWX6.js";
import {
  d
} from "./chunk-BCN3HEUP.js";
import {
  L,
  O,
  Q
} from "./chunk-JID2PGFV.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-HVRIX7CX.js";
import "./chunk-GCTIF24Q.js";
import "./chunk-RXG6HQCK.js";
import "./chunk-OETYRBST.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-EWC2SUBD.js";
import "./chunk-X2R3FJBU.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-Z7YG4UNG.js";
import "./chunk-2CS746FZ.js";
import "./chunk-6YSDDH6K.js";
import "./chunk-MCOL2MI5.js";
import "./chunk-AVMLDZZZ.js";
import "./chunk-IQQJPZC6.js";
import "./chunk-B5AZBN2H.js";
import {
  y
} from "./chunk-C6OAHV3Z.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-UYERGX5D.js";
import "./chunk-BTVDNPEM.js";
import "./chunk-3U5B3VOX.js";
import "./chunk-ZAUL2HRL.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-5ZJMLCBK.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-D4S6H6HS.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-IDSV3U3M.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-N7OU5PYY.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-3LTBYQQS.js";
import "./chunk-YXZLRZNZ.js";
import "./chunk-YVNZKO6I.js";
import {
  a as a2,
  h as h2,
  l
} from "./chunk-27M3EN5Y.js";
import "./chunk-DQBIAKCW.js";
import "./chunk-MOMLPET6.js";
import "./chunk-P5FXO7WR.js";
import "./chunk-UCCG5WDW.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-WAXP6XIO.js";
import {
  P
} from "./chunk-IVKSCXGN.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-DDNC6A36.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-T6TMEQJ7.js";
import "./chunk-5DBBCQVU.js";
import "./chunk-MNW46TV4.js";
import "./chunk-JSWMPOBX.js";
import "./chunk-SSVCVBFL.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-5KQMTKIZ.js";
import "./chunk-PYBAZ6YE.js";
import "./chunk-YC5GI5YQ.js";
import {
  b,
  m
} from "./chunk-RJI4N3LT.js";
import {
  a2 as a
} from "./chunk-QSG5WGQI.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-CM3TIXEV.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-3TN73U7K.js";
import "./chunk-SL5A7INV.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-YO7WHZZ7.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-JNYZ3I5R.js";
import {
  g,
  h,
  s
} from "./chunk-Q6OL33PY.js";
import "./chunk-TJPLHZCD.js";
import {
  S
} from "./chunk-KLFJ5V5G.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z = "graphics-collections";
var O2 = class extends b {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const r3 = async (o3, r4) => (await h(e.whenLayerView(t2), r4)).elevationAlignPointsInFeatures(o3, r4);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: r3 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r2(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, r3 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && r3 ? n(r3, (async (o3, r4) => {
      const s3 = await e.whenLayerView(t2);
      return s(r4), s3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, r4);
    })) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h3(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources(((e) => this._destroySource(e))), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add((() => this.getGraphicsLayers()), ((e2) => {
      this._updatingHandles.removeHandles(z);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", ((e3) => this._onGraphicUpdate(e3))), this._updatingHandles.addOnCollectionChange((() => t3.graphics), ((e3) => this._onGraphicsChanged(e3)))], z);
    }), h2);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", (({ context: e2 }) => {
      y2(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    })), l((() => t2.elevationInfo), (() => this._snappingElevationAligner.notifyElevationSourceChange()), h2), a2((() => t2), ["edits", "apply-edits", "graphic-update"], (() => this._symbologySnappingFetcher.notifySymbologyChange()))]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: r3 } } = e, s3 = await g(this._mapSources(((o3) => this._fetchCandidatesForSource(o3, e, t2))));
    s(t2);
    const a4 = this._memoizedMakeGetGroundElevation(this.view, r3), p = s3.flat().map(((e2) => o(e2, a4)));
    return E(o2, p), p;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    const r3 = y3({ parameters: t2, mode: this.view?.type ?? "2d" }), s3 = await u(e.queryEngine, r3, o2);
    s(o2);
    const n2 = await this._snappingElevationAligner.alignCandidates(s3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a4 = await this._symbologySnappingFetcher.fetch(n2, o2);
    s(o2);
    const p = 0 === a4.length ? n2 : [...n2, ...a4];
    return this._snappingElevationFilter.filter(r3, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some(((t2) => t2.graphics.includes(e.graphic)))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const r3 of e) null != r3.geometry && (this._needsInitializeProjection(r3.geometry.spatialReference) ? (t2.push(r3.geometry.spatialReference), o2.set(r3.uid, r3)) : this._add(r3));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const s3 = d((async (o2) => {
      await Q(e.map(((e2) => ({ source: e2, dest: this.spatialReference }))), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    }));
    this._updatingHandles.addPromise(s3.promise);
    const i3 = { task: s3, graphics: t2 }, n2 = () => S(this._pendingAdds, i3);
    s3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = P.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const r3 = this._createOptimizedFeature(e.uid, t2);
    null != r3 && (o2.featureStore.add(r3), A(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !L(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = O(a3(t2), this.spatialReference);
    if (!o2) return null;
    const r3 = this._ensureGeometryHasZ(o2), s3 = ut(r3, this._hasZ, false);
    return new s2(s3, { [Z2]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach(((e2) => e2.forEach(t2)));
        break;
      case "polygon":
        o2.rings.forEach(((e2) => e2.forEach(t2)));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y.toJSON(e), o2 = this._hasZ, r3 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: r3, queryEngine: new L2({ featureStore: r3, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: Z2, type: "esriFieldTypeOID", alias: Z2 }] }), geometryType: t2, hasM: false, hasZ: o2, featureIdInfo: { type: "object-id", fieldName: Z2 }, spatialReference: this.spatialReference, priority: g2.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources(((t2) => this._removeFromSource(t2, e)));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), A(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: r3, multipoint: s3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != r3 && i3.push(e(r3)), null != s3 && i3.push(e(s3)), i3;
  }
};
r([m()], O2.prototype, "getGraphicsLayers", void 0), r([m({ constructOnly: true })], O2.prototype, "layerSource", void 0), r([m({ constructOnly: true })], O2.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], O2.prototype, "view", void 0), r([m({ readOnly: true })], O2.prototype, "updating", null), r([m({ readOnly: true })], O2.prototype, "availability", void 0), r([m()], O2.prototype, "_hasZ", null), r([m()], O2.prototype, "_snappingElevationAligner", null), r([m()], O2.prototype, "_snappingElevationFilter", null), r([m()], O2.prototype, "_symbologySnappingFetcher", null), r([m()], O2.prototype, "_extrudedPolygonSymbolsCount", void 0), O2 = r([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O2);
var Z2 = "OBJECTID";
export {
  O2 as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-HVGAR4IZ.js.map
