import {
  f
} from "./chunk-ZAUL2HRL.js";
import "./chunk-IVKSCXGN.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-DDNC6A36.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-T6TMEQJ7.js";
import "./chunk-5DBBCQVU.js";
import "./chunk-MNW46TV4.js";
import "./chunk-JSWMPOBX.js";
import "./chunk-SSVCVBFL.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-5KQMTKIZ.js";
import "./chunk-PYBAZ6YE.js";
import "./chunk-YC5GI5YQ.js";
import "./chunk-RJI4N3LT.js";
import "./chunk-QSG5WGQI.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-3TN73U7K.js";
import "./chunk-SL5A7INV.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-YO7WHZZ7.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-Q6OL33PY.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/arcade/geometry/operatorsWorker.js
function t(e, t2) {
  let r2;
  return { loaded: false, load: () => r2 ??= t2().then(((t3) => {
    o[e] = { loaded: true, execute: t3 };
  })) };
}
function r(e) {
  return null == e ? null : e.toJSON();
}
var o = { disjoint: t("disjoint", (() => import("./disjointOperator-D6O5MCPR.js").then(((e) => e.execute)))), intersects: t("intersects", (() => import("./intersectsOperator-WU337IXF.js").then(((e) => e.execute)))), touches: t("touches", (() => import("./touchesOperator-IQMMGFBB.js").then(((e) => e.execute)))), crosses: t("crosses", (() => import("./crossesOperator-EGDRRKG5.js").then(((e) => e.execute)))), within: t("within", (() => import("./withinOperator-KRXNARSA.js").then(((e) => e.execute)))), contains: t("contains", (() => import("./containsOperator-BP45J7VA.js").then(((e) => e.execute)))), overlaps: t("overlaps", (() => import("./overlapsOperator-M72NHE6C.js").then(((e) => e.execute)))), equals: t("equals", (async () => {
  const t2 = await import("./equalsOperator-IVLDBPFI.js");
  return (r2, o2) => t2.execute(f(r2), f(o2));
})), relate: t("relate", (async () => {
  const t2 = await import("./relateOperator-R65XX3VO.js");
  return (r2, o2, n2) => t2.execute(f(r2), f(o2), n2);
})), intersection: t("intersection", (() => import("./intersectionOperator-GLM4KFHB.js").then(((e) => e.execute)))), union: t("union", (() => import("./unionOperator-IZG4CKKS.js").then(((e) => e.executeMany)))), difference: t("difference", (async () => {
  const t2 = await import("./differenceOperator-AHFJJCNI.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), symmetricDifference: t("symmetricDifference", (async () => {
  const t2 = await import("./symmetricDifferenceOperator-2HUCBHQB.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), clip: t("clip", (async () => {
  const t2 = await import("./clipOperator-WZ53EVRK.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), cut: t("cut", (async () => {
  const t2 = await import("./cutOperator-MR3IJ74O.js");
  return (o2, n2) => t2.execute(f(o2), f(n2)).map(((e) => r(e)));
})), area: t("area", (async () => {
  const t2 = await import("./areaOperator-Z7ILIC4O.js"), { convertFromSpatialReferenceUnit: r2, toAreaUnit: o2 } = await import("./unitConversion-BFUWYELG.js");
  return (n2, a) => {
    const s = t2.execute(f(n2));
    return r2(n2.spatialReference, o2(a), s);
  };
})), geodeticArea: t("geodeticArea", (async () => {
  const t2 = await import("./geodeticAreaOperator-ULBWFKLV.js"), { convert: r2, squareMeters: o2, toAreaUnit: n2 } = await import("./unitConversion-BFUWYELG.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), length: t("length", (async () => {
  const e = await import("./lengthOperator-67Y4724A.js"), { convertFromSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BFUWYELG.js");
  return (o2, n2) => {
    const a = e.execute(o2);
    return t2(o2.spatialReference, r2(n2), a);
  };
})), geodeticLength: t("geodeticLength", (async () => {
  const t2 = await import("./geodeticLengthOperator-PYI2KCHO.js"), { convert: r2, meters: o2, toLengthUnit: n2 } = await import("./unitConversion-BFUWYELG.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), distance: t("distance", (async () => {
  const t2 = await import("./distanceOperator-FTXFP7OO.js"), { convertFromSpatialReferenceUnit: r2, toLengthUnit: o2 } = await import("./unitConversion-BFUWYELG.js");
  return (n2, a, s) => {
    const i = t2.execute(f(n2), f(a));
    return r2(n2.spatialReference, o2(s), i);
  };
})), densify: t("densify", (async () => {
  const t2 = await import("./densifyOperator-YHVZRFRZ.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-BFUWYELG.js");
  return (a, s, i) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s)));
})), geodeticDensify: t("geodeticDensify", (async () => {
  const t2 = await import("./geodeticDensifyOperator-LIH65SAN.js"), { convert: o2, meters: n2, toLengthUnit: a } = await import("./unitConversion-BFUWYELG.js");
  return await t2.load(), (s, i, c, p) => (i = o2(a(c), n2, i), r(t2.execute(f(s), i, { curveType: p })));
})), generalize: t("generalize", (async () => {
  const t2 = await import("./generalizeOperator-73I4QX3E.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-BFUWYELG.js");
  return (a, s, i, c) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s, c)));
})), buffer: t("buffer", (async () => {
  const e = await import("./bufferOperator-6QEEY4IU.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BFUWYELG.js");
  return (o2, n2, a) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2));
})), geodesicBuffer: t("geodesicBuffer", (async () => {
  const e = await import("./geodesicBufferOperator-T2UYGY3C.js"), { convert: t2, meters: r2, toLengthUnit: o2 } = await import("./unitConversion-BFUWYELG.js");
  return await e.load(), (n2, a, s, i) => (a = t2(o2(s), r2, a), e.execute(n2, a, { curveType: i }));
})), offset: t("offset", (async () => {
  const e = await import("./offsetOperator-O6UNFRJY.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-BFUWYELG.js");
  return (o2, n2, a, s) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2, s));
})), rotate: t("rotate", (async () => {
  const t2 = await import("./affineTransformOperator-SX2QZJLX.js"), { default: o2 } = await import("./Transformation-4VJ3ZI76.js");
  return (n2, a, s, i) => {
    const c = new o2().rotate(a, s, i);
    return r(t2.execute(f(n2), c));
  };
})), centroid: t("centroid", (async () => {
  const t2 = await import("./centroidOperator-B3IYRZBX.js");
  return (o2) => r(t2.execute(f(o2)));
})), labelPoint: t("labelPoint", (async () => {
  const t2 = await import("./labelPointOperator-LR3GKWOE.js");
  return (o2) => r(t2.execute(f(o2)));
})), simplify: t("simplify", (() => import("./simplifyOperator-GUOAP24O.js").then(((e) => e.execute)))), isSelfIntersecting: t("isSelfIntersecting", (async () => {
  const { NonSimpleResult: t2 } = await import("./OperatorDefinitions-TZVT2JPF.js"), r2 = await import("./simplifyOGCOperator-FAJJ2GGB.js"), o2 = /* @__PURE__ */ new Set([5, 6, 7, 10, 11, 12]);
  return (n2) => {
    const a = new t2();
    return !r2.isSimple(f(n2), a) && o2.has(a.m_reason);
  };
})), isSimple: t("isSimple", (() => import("./simplifyOperator-GUOAP24O.js").then(((e) => e.isSimple)))), convexHull: t("convexHull", (() => import("./convexHullOperator-QDRRIVVC.js").then(((e) => e.execute)))), getNearestCoordinate: t("getNearestCoordinate", (async () => {
  const t2 = await import("./proximityOperator-GV4LFHK7.js");
  return (o2, n2, a) => {
    const s = t2.getNearestCoordinate(f(o2), f(n2), a);
    return { ...s, coordinate: r(s.coordinate) };
  };
})), getNearestVertex: t("getNearestVertex", (async () => {
  const t2 = await import("./proximityOperator-GV4LFHK7.js");
  return (o2, n2) => {
    const a = t2.getNearestVertex(f(o2), f(n2));
    return { ...a, coordinate: r(a.coordinate) };
  };
})) };
function n(e, t2) {
  const r2 = o[e];
  return r2.loaded ? r2.execute.apply(void 0, t2) : r2.load().then((() => n(e, t2)));
}
export {
  n as invokeGeometryOp
};
//# sourceMappingURL=operatorsWorker-QJAZ2TY4.js.map
