import {
  c,
  i
} from "./chunk-4IPCRCZO.js";
import {
  G,
  _,
  r
} from "./chunk-5KQMTKIZ.js";
import "./chunk-RJI4N3LT.js";
import "./chunk-QSG5WGQI.js";
import "./chunk-X26VPODZ.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-3TN73U7K.js";
import "./chunk-SL5A7INV.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-YO7WHZZ7.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-Q6OL33PY.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/geometry/operators/support/geographicTransformationUtils.js
var s;
var i2;
var a;
var c2;
function p() {
  return !!s && r();
}
async function m() {
  if (!p()) {
    const [t, e, r2, p2] = await Promise.all([import("./Envelope2D-DYWPGAXY.js"), import("./ProjectionTransformation-QMVDRBGR.js").then(((n) => n.aK)).then((({ queryTransformationList: n }) => n)), import("./ProjectionTransformation-QMVDRBGR.js").then(((n) => n.aG)).then((({ injectPe: n }) => n)), import("./apiConverter-U4MJGQU7.js"), _()]);
    c2 = t.Envelope2D.constructEmpty(), s = e, r2(G), i2 = p2.fromExtent, a = p2.fromSpatialReference;
  }
}
function u(n, t, o = null) {
  const e = o ? i2(o).asEnvelope2D() : c2, r2 = s(0, a(n), a(t), e, 1, true);
  return r2.length > 0 ? l(r2[0]) : null;
}
function f(n, t, o = null) {
  const e = o ? i2(o).asEnvelope2D() : c2;
  return s(0, a(n), a(t), e, 0, true).map(((n2) => l(n2)));
}
function l(n) {
  const t = new c();
  for (let o = 0; o < n.count(); o++) {
    const e = n.getStep(o);
    t.steps.push(new i({ wkid: e.getID(), isInverse: e.isInverted() }));
  }
  return t;
}
export {
  u as getTransformation,
  f as getTransformations,
  p as isLoaded,
  m as load
};
//# sourceMappingURL=geographicTransformationUtils-7N2CM374.js.map
