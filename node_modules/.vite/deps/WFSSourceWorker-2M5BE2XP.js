import {
  K,
  ee,
  oe
} from "./chunk-WBDPUEGA.js";
import "./chunk-THA6KPOR.js";
import {
  E,
  N
} from "./chunk-KBMXFWVV.js";
import {
  d as d2
} from "./chunk-QT2HWBGD.js";
import "./chunk-XF5GRUK5.js";
import {
  u
} from "./chunk-6GWZRS3D.js";
import {
  f
} from "./chunk-P55IKTJZ.js";
import "./chunk-PVUHK5FP.js";
import "./chunk-ITDL4YVK.js";
import {
  L
} from "./chunk-LHDS43CC.js";
import "./chunk-CCQBS25D.js";
import "./chunk-TBTLKLMN.js";
import "./chunk-SOILZBUC.js";
import {
  j,
  x
} from "./chunk-WXBUIB3W.js";
import "./chunk-OXO3GGCE.js";
import {
  lt,
  ut
} from "./chunk-MP5M3F6E.js";
import "./chunk-7Y4U2JD3.js";
import "./chunk-GCTSCKPO.js";
import "./chunk-6U4EGJOK.js";
import "./chunk-W7U4L72B.js";
import "./chunk-DDDZPNGZ.js";
import "./chunk-UZFYMLRD.js";
import "./chunk-BCUZY6HJ.js";
import "./chunk-EVMYKI66.js";
import "./chunk-4SIT2BLP.js";
import "./chunk-RWNJO2QP.js";
import "./chunk-6EYNEIU4.js";
import "./chunk-2EW4QRCK.js";
import "./chunk-JTZ24OTF.js";
import "./chunk-YNVT2YMA.js";
import "./chunk-MFUILZVS.js";
import "./chunk-FCLAVZUU.js";
import "./chunk-KPGNM4LZ.js";
import "./chunk-C7LICITY.js";
import "./chunk-7WPGDYQW.js";
import "./chunk-OTNN4DZS.js";
import "./chunk-OUR2XGMQ.js";
import "./chunk-RYA5LLOM.js";
import {
  Z
} from "./chunk-XZ46MCDO.js";
import "./chunk-UICDKBDP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-G2VWR52Q.js";
import "./chunk-EMULKSUV.js";
import "./chunk-AY3JR4QM.js";
import "./chunk-RSDQMJRT.js";
import "./chunk-3CFYBBSV.js";
import {
  d
} from "./chunk-BCN3HEUP.js";
import "./chunk-JID2PGFV.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-HVRIX7CX.js";
import "./chunk-GCTIF24Q.js";
import "./chunk-OETYRBST.js";
import "./chunk-X2R3FJBU.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-C6OAHV3Z.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-UYERGX5D.js";
import "./chunk-BTVDNPEM.js";
import "./chunk-3U5B3VOX.js";
import "./chunk-ZAUL2HRL.js";
import {
  n as n2
} from "./chunk-FOPBVVXE.js";
import "./chunk-D4S6H6HS.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-IDSV3U3M.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-N7OU5PYY.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-3LTBYQQS.js";
import "./chunk-27M3EN5Y.js";
import "./chunk-DQBIAKCW.js";
import {
  n
} from "./chunk-MOMLPET6.js";
import "./chunk-P5FXO7WR.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-WAXP6XIO.js";
import "./chunk-IVKSCXGN.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-DDNC6A36.js";
import {
  r
} from "./chunk-ZJQPHR3K.js";
import "./chunk-T6TMEQJ7.js";
import "./chunk-5DBBCQVU.js";
import "./chunk-MNW46TV4.js";
import "./chunk-JSWMPOBX.js";
import "./chunk-SSVCVBFL.js";
import {
  s as s4
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-5KQMTKIZ.js";
import "./chunk-PYBAZ6YE.js";
import "./chunk-YC5GI5YQ.js";
import "./chunk-RJI4N3LT.js";
import {
  s as s2
} from "./chunk-QSG5WGQI.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-3TN73U7K.js";
import "./chunk-SL5A7INV.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-YO7WHZZ7.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-JNYZ3I5R.js";
import {
  b,
  s as s3
} from "./chunk-Q6OL33PY.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-GNMFMITH.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var S = "esri.layers.WFSLayer";
var j2 = class {
  constructor() {
    this._customParameters = null, this._queryEngine = null, this._supportsPagination = true;
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  async load(e, r2 = {}) {
    const { getFeatureUrl: a, getFeatureOutputFormat: o, fields: n3, geometryType: i2, featureType: u2, maxRecordCount: l, maxTotalRecordCount: c, maxPageCount: p, objectIdField: f2, customParameters: g } = e, { spatialReference: y, getFeatureSpatialReference: x2 } = oe(a, u2, e.spatialReference);
    try {
      await x(x2, y);
    } catch {
      throw new s("unsupported-projection", "Projection not supported", { inSpatialReference: x2, outSpatialReference: y });
    }
    s3(r2), this._customParameters = g, this._featureType = u2, this._fieldsIndex = Z.fromLayerJSON({ fields: n3, dateFieldsTimeReference: n3.some(((e2) => "esriFieldTypeDate" === e2.type)) ? { timeZoneIANA: n } : null }), this._geometryType = i2, this._getFeatureUrl = a, this._getFeatureOutputFormat = o, this._getFeatureSpatialReference = x2, this._maxRecordCount = l, this._maxTotalRecordCount = c, this._maxPageCount = p, this._objectIdField = f2, this._spatialReference = y;
    let C = await this._snapshotFeatures(r2);
    if (C.errors.length > 0 && (this._supportsPagination = false, C = await this._snapshotFeatures(r2), C.errors.length > 0)) throw C.errors[0];
    const R = { type: "object-id", fieldName: f2 };
    return this._queryEngine = new L({ fieldsIndex: this._fieldsIndex, geometryType: i2, hasM: false, hasZ: false, featureIdInfo: R, spatialReference: y, timeInfo: null, featureStore: new f({ geometryType: i2, hasM: false, hasZ: false }) }), this._queryEngine.featureStore.addMany(C.features), { warnings: q(C), extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    await this._waitSnapshotComplete();
    return (await this._queryEngine.executeQueryForIds(e, t.signal)).filter(n2);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), u(this._queryEngine, e, t.signal);
  }
  async queryAttributeBins(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e, t.signal);
  }
  async refresh(t) {
    return this._customParameters = t.customParameters, this._maxRecordCount = t.maxRecordCount, this._maxTotalRecordCount = t.maxTotalRecordCount, this._maxPageCount = t.maxPageCount, this._snapshotTask?.abort(), this._snapshotTask = d(((e) => this._snapshotFeatures({ signal: e }))), this._snapshotTask.promise.then(((e) => {
      this._queryEngine.featureStore.clear(), this._queryEngine.featureStore.addMany(e.features);
      for (const t2 of q(e)) i.getLogger(S).warn(new s2("wfs-layer:refresh-warning", t2.message, t2.details));
      e.errors?.length && i.getLogger(S).warn(new s2("wfs-layer:refresh-error", "Refresh completed with errors", { errors: e.errors }));
    }), (() => {
      this._queryEngine.featureStore.clear();
    })), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _snapshotFeatures(e) {
    const t = e?.signal, r2 = this._maxTotalRecordCount, n3 = this._maxPageCount, i2 = this._supportsPagination && n3 > 1 ? await ee(this._getFeatureUrl, this._featureType.typeName, { customParameters: this._customParameters, signal: t }) : void 0;
    let u2 = [];
    const l = [];
    if (null == i2) try {
      u2 = await this._singleQuery(t);
    } catch (c) {
      b(c) || l.push(c);
    }
    else {
      const e2 = Math.min(i2, r2), s5 = T(this, r(Math.ceil(e2 / this._maxRecordCount), 1, n3), t);
      await Promise.allSettled(Array.from({ length: 10 }).map((() => E2(s5, u2, l))));
    }
    return s3(t), { features: u2, totalRecordCount: i2, maxTotalRecordCount: r2, maxPageCount: n3, errors: l };
  }
  async _singleQuery(e) {
    const t = Number.isFinite(this._maxRecordCount) && this._maxRecordCount > 0 ? this._maxRecordCount : void 0, r2 = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, count: t, signal: e });
    return this._processGeoJSON(r2, { signal: e });
  }
  async _pageQuery(e, t) {
    const r2 = e * this._maxRecordCount, a = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, startIndex: r2, count: this._maxRecordCount, signal: t });
    return this._processGeoJSON(a, { startIndex: r2, signal: t });
  }
  _processGeoJSON(e, t) {
    E(e, this._getFeatureSpatialReference.wkid);
    const { startIndex: r2, signal: a } = t;
    s3(a);
    const o = N(e, { geometryType: this._geometryType, hasZ: false, objectIdField: this._objectIdField });
    if (!s4(this._spatialReference, this._getFeatureSpatialReference)) for (const s5 of o) null != s5.geometry && (s5.geometry = ut(j(lt(s5.geometry, this._geometryType, false, false), this._getFeatureSpatialReference, this._spatialReference)));
    let n3 = r2 ?? 1;
    for (const s5 of o) {
      const e2 = {};
      d2(this._fieldsIndex, e2, s5.attributes, true), s5.attributes = e2, null == e2[this._objectIdField] && (s5.objectId = e2[this._objectIdField] = n3++);
    }
    return o;
  }
};
function* T(e, t, r2) {
  for (let a = 0; a < t; a++) yield e._pageQuery(a, r2);
}
async function E2(e, t, r2) {
  let a = e.next();
  for (; !a.done; ) {
    try {
      const e2 = await a.value;
      t.push(...e2);
    } catch (s5) {
      b(s5) || r2.push(s5);
    }
    a = e.next();
  }
}
function q(e) {
  const t = [];
  return null != e.totalRecordCount && (e.features.length < e.totalRecordCount && t.push({ name: "wfs-layer:maxRecordCount-too-low", message: `Could only fetch ${e.features.length} of ${e.totalRecordCount} in ${e.maxPageCount} queries. Try increasing the value of WFSLayer.maxRecordCount.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount } }), e.totalRecordCount > e.maxTotalRecordCount && t.push({ name: "wfs-layer:large-dataset", message: `The number of ${e.totalRecordCount} features exceeds the maximum allowed of ${e.maxTotalRecordCount}.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount, maxTotalRecordCount: e.maxTotalRecordCount } })), t;
}
export {
  j2 as default
};
//# sourceMappingURL=WFSSourceWorker-2M5BE2XP.js.map
